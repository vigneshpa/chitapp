{"version":3,"file":"js/315.js","mappings":"6IAwBO,SAASA,QAAQC,EAAaC,GA2BnC,IAAIC,EAAU,IAAIC,QAElB,OAAO,SAAUC,EAAMC,EAAOC,GAG5B,IAAIC,EACAC,EAWJ,YAPiBC,IAAbR,IACFI,EAAQJ,EAASI,IAOA,iBAAVA,GACG,OAAVA,GACEA,aAAiBK,SACjBL,aAAiBM,MACjBN,aAAiBO,QACjBP,aAAiBQ,QACjBR,aAAiBS,OAgCdT,OAzBYI,KADjBF,EAAWL,EAAQa,IAAIV,IAEd,CAAEW,KAAMT,IAKjBL,EAAQe,IAAIZ,EAAOC,GAIfY,MAAMC,QAAQd,IAChBG,EAAK,GACLH,EAAMe,SAAQ,SAAUC,EAASC,GAC/Bd,EAAGc,GAAKlB,EAAMiB,EAASf,EAAO,IAAMgB,EAAI,UAK1Cd,EAAK,GACLe,OAAOC,KAAKnB,GAAOe,SAAQ,SAAUK,GACnCjB,EAAGiB,GAAQrB,EAAMC,EAAMoB,GAAOnB,EAAO,IAAMoB,KAAKC,UAAUF,GAAQ,SAG/DjB,GApDJ,CAuDJR,EAAQ,KAGN,SAAS4B,WAAWC,GAsBzB,IAAIC,GAAK,qFAmCT,OAjCA,SAAUC,IAAI1B,OAMRA,OAA0B,iBAAVA,QACda,MAAMC,QAAQd,OAChBA,MAAMe,SAAQ,SAAUC,QAASC,GAC/B,GAAuB,iBAAZD,SAAoC,OAAZA,QAAkB,CACnD,IAAIf,KAAOe,QAAQL,KACC,iBAATV,MAAqBwB,GAAGE,KAAK1B,MACtCD,MAAMiB,GAAKW,KAAK3B,MAEhByB,IAAIV,aAKVE,OAAOC,KAAKnB,OAAOe,SAAQ,SAAUK,MACnC,IAAIS,KAAO7B,MAAMoB,MACjB,GAAoB,iBAATS,MAA8B,OAATA,KAAe,CAC7C,IAAI5B,KAAO4B,KAAKlB,KACI,iBAATV,MAAqBwB,GAAGE,KAAK1B,MACtCD,MAAMoB,MAAQQ,KAAK3B,MAEnByB,IAAIG,WA1BhB,CAgCGL,GACIA,E","sources":["webpack:///./src/cycle.ts"],"sourcesContent":["/*\n    cycle.js\n    2021-05-31\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See https://www.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n// The file uses the WeakMap feature of ES6.\n\n/*jslint eval */\n\n/*property\n    $ref, decycle, forEach, get, indexOf, isArray, keys, length, push,\n    retrocycle, set, stringify, test\n*/\n\nexport function decycle(object: any, replacer?: any) {\n  'use strict';\n\n  // Make a deep copy of an object or array, assuring that there is at most\n  // one instance of each object or array in the resulting structure. The\n  // duplicate references (which might be forming cycles) are replaced with\n  // an object of the form\n\n  //      {\"$ref\": PATH}\n\n  // where the PATH is a JSONPath string that locates the first occurance.\n\n  // So,\n\n  //      var a = [];\n  //      a[0] = a;\n  //      return JSON.stringify(JSON.decycle(a));\n\n  // produces the string '[{\"$ref\":\"$\"}]'.\n\n  // If a replacer function is provided, then it will be called for each value.\n  // A replacer function receives a value and returns a replacement value.\n\n  // JSONPath is used to locate the unique object. $ indicates the top level of\n  // the object or array. [NUMBER] or [STRING] indicates a child element or\n  // property.\n\n  var objects = new WeakMap(); // object to path mappings\n\n  return (function derez(value, path) {\n    // The derez function recurses through the object, producing the deep copy.\n\n    var old_path; // The path of an earlier occurance of value\n    var nu: any; // The new object or array\n\n    // If a replacer function was provided, then call it to get a replacement value.\n\n    if (replacer !== undefined) {\n      value = replacer(value);\n    }\n\n    // typeof null === \"object\", so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    if (\n      typeof value === 'object' &&\n      value !== null &&\n      !(value instanceof Boolean) &&\n      !(value instanceof Date) &&\n      !(value instanceof Number) &&\n      !(value instanceof RegExp) &&\n      !(value instanceof String)\n    ) {\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a {\"$ref\":PATH} object. This uses an\n      // ES6 WeakMap.\n\n      old_path = objects.get(value);\n      if (old_path !== undefined) {\n        return { $ref: old_path };\n      }\n\n      // Otherwise, accumulate the unique value and its path.\n\n      objects.set(value, path);\n\n      // If it is an array, replicate the array.\n\n      if (Array.isArray(value)) {\n        nu = [];\n        value.forEach(function (element, i) {\n          nu[i] = derez(element, path + '[' + i + ']');\n        });\n      } else {\n        // If it is an object, replicate the object.\n\n        nu = {};\n        Object.keys(value).forEach(function (name) {\n          nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n        });\n      }\n      return nu;\n    }\n    return value;\n  })(object, '$');\n}\n\nexport function retrocycle($: any) {\n  'use strict';\n\n  // Restore an object that was reduced by decycle. Members whose values are\n  // objects of the form\n  //      {$ref: PATH}\n  // are replaced with references to the value found by the PATH. This will\n  // restore cycles. The object will be mutated.\n\n  // The eval function is used to locate the values described by a PATH. The\n  // root object is kept in a $ variable. A regular expression is used to\n  // assure that the PATH is extremely well formed. The regexp contains nested\n  // * quantifiers. That has been known to have extremely bad performance\n  // problems on some browsers for very long strings. A PATH is expected to be\n  // reasonably short. A PATH is allowed to belong to a very restricted subset of\n  // Goessner's JSONPath.\n\n  // So,\n  //      var s = '[{\"$ref\":\"$\"}]';\n  //      return JSON.retrocycle(JSON.parse(s));\n  // produces an array containing a single element which is the array itself.\n\n  var px = /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\\])*$/;\n\n  (function rez(value) {\n    // The rez function walks recursively through the object looking for $ref\n    // properties. When it finds one that has a value that is a path, then it\n    // replaces the $ref object with a reference to the value that is found by\n    // the path.\n\n    if (value && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        value.forEach(function (element, i) {\n          if (typeof element === 'object' && element !== null) {\n            var path = element.$ref;\n            if (typeof path === 'string' && px.test(path)) {\n              value[i] = eval(path);\n            } else {\n              rez(element);\n            }\n          }\n        });\n      } else {\n        Object.keys(value).forEach(function (name) {\n          var item = value[name];\n          if (typeof item === 'object' && item !== null) {\n            var path = item.$ref;\n            if (typeof path === 'string' && px.test(path)) {\n              value[name] = eval(path);\n            } else {\n              rez(item);\n            }\n          }\n        });\n      }\n    }\n  })($);\n  return $;\n}\n"],"names":["decycle","object","replacer","objects","WeakMap","derez","value","path","old_path","nu","undefined","Boolean","Date","Number","RegExp","String","get","$ref","set","Array","isArray","forEach","element","i","Object","keys","name","JSON","stringify","retrocycle","$","px","rez","test","eval","item"],"sourceRoot":""}