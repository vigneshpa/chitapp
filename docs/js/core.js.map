{"version":3,"file":"js/core.js","mappings":"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","sources":["webpack:///../core/src/Actions/checkPhone.ts","webpack:///../core/src/utils.ts","webpack:///../core/src/Entites/Model.ts","webpack:///../core/src/Entites/Group.ts","webpack:///../core/src/Entites/Client.ts","webpack:///../core/src/Entites/Chit.ts","webpack:///../core/src/Entites/Payment.ts","webpack:///../core/src/Actions/createChit.ts","webpack:///../core/src/Actions/createGroup.ts","webpack:///../core/src/Actions/createClient.ts","webpack:///../core/src/Actions/findChits.ts","webpack:///../core/src/Actions/findGroups.ts","webpack:///../core/src/Actions/findClients.ts","webpack:///../core/src/Actions/checkGroup.ts","webpack:///../core/src/index.ts","webpack:///../core/src/Actions/index.ts","webpack:///./src/Core.ts"],"sourcesContent":["import type Repos from '../Entites';\n\nexport default function makeCheckPhone(repos: Repos) {\n  return async function checkPhone({ phone }: { phone: string }) {\n    // Checking existance\n    let count = await repos.Client.findOne({ phone });\n    return count?.name || false;\n  };\n}\n","\nexport function isFiniteUnSignInteger(num:number){\n  return Number.isSafeInteger(num) && Number.isFinite(num) && num >= 0;\n}","import { PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, BeforeInsert, Entity } from 'typeorm';\nimport { v4 } from 'uuid';\n\n@Entity()\nexport default abstract class Model {\n  @PrimaryGeneratedColumn()\n  private id!: number;\n\n  @Column({ type: 'uuid', unique: true })\n  readonly uuid: string;\n\n  @CreateDateColumn()\n  readonly createdAt!: Date;\n\n  @UpdateDateColumn()\n  readonly updatedAt!: Date;\n\n  constructor(uuid?:string) {\n    this.uuid = uuid || v4();\n  }\n\n}\n","import { Entity, Column, OneToMany, BeforeInsert } from 'typeorm';\nimport Chit from './Chit';\nimport Model from './Model';\nimport type { RangeOf2 } from '../vendorTypes';\n\n@Entity()\nexport default class Group extends Model {\n  @Column({ unique: true })\n  name!: string;\n\n  @Column({ nullable: false })\n  batch!: string;\n\n  @Column('integer')\n  month!: RangeOf2<1, 12>;\n\n  @Column({ nullable: false })\n  year!: number;\n\n  @Column({ nullable: false, type: 'integer' })\n  totalValue!: number;\n\n  @Column({ nullable: false })\n  isActive: boolean = false;\n\n  @OneToMany(type => Chit, Chit => Chit.group, { cascade: true })\n  chits!: Chit[];\n\n  /**\n   * This method tests all the chits and activates\n   * the group if conditions are satisfied\n   *\n   * Warning: Once activated it cannot be modified\n   */\n  activate() {\n    // Vaidating totsum of all chits value\n    if (this.isActive) throw new Error('Group is already active');\n    let chitsTotalValue = 0;\n    this.chits.forEach(chit => {\n      chitsTotalValue += chit.value;\n    });\n    if (chitsTotalValue < this.totalValue) throw new Error('Chits are not sufficient');\n    if (chitsTotalValue > this.totalValue) throw new Error('Chits are more than the limit');\n    (this.isActive as boolean) = true;\n  }\n}\n","import { Entity, Column, OneToMany } from 'typeorm';\nimport Chit from './Chit';\nimport Model from './Model';\n\n@Entity()\nexport default class Client extends Model {\n  @Column()\n  name!: string;\n\n  @Column()\n  phone!: string;\n\n  @Column()\n  address!: string;\n\n  @OneToMany(type => Chit, Chit => Chit.client)\n  chits!: Chit[];\n}\n","import { Entity, JoinColumn, ManyToOne, Column, OneToMany } from 'typeorm';\nimport Payment from './Payment';\nimport Group from './Group';\nimport Client from './Client';\nimport Model from './Model';\nimport type { RangeOf2 } from '../vendorTypes';\n\n@Entity()\nexport default class Chit extends Model {\n  @JoinColumn()\n  @ManyToOne(type => Client, Client => Client.chits)\n  client!: Client;\n\n  @JoinColumn()\n  @ManyToOne(type => Group, Group => Group.chits)\n  group!: Group;\n\n  @Column({ nullable: false, type: 'integer' })\n  value!: number;\n\n  @OneToMany(type => Payment, Payment => Payment.chit, { cascade: true })\n  payments!: Payment[];\n\n  @Column({ type: 'integer', nullable: true })\n  wonAtMonth: RangeOf2<1, 20> | null = null;\n}\n","import type { RangeOf2 } from '../vendorTypes';\nimport { Entity, ManyToOne, JoinColumn, Column } from 'typeorm';\nimport Chit from './Chit';\nimport Model from './Model';\n\n@Entity()\nexport default class Payment extends Model {\n  @JoinColumn()\n  @ManyToOne(type => Chit, Chit => Chit.payments)\n  chit!: Chit;\n\n  @Column('integer', { nullable: false })\n  imonth!: RangeOf2<1, 20>;\n\n  @Column({ nullable: false })\n  ispaid!: boolean;\n\n  get toBePaid(): number {\n    let base = this.chit.value / 20;\n    const intrest = base / 5;\n\n    // Adding interest if the chit is won before this payment\n    if (this.chit.wonAtMonth && this.chit.wonAtMonth < this.imonth) base += intrest;\n    return base;\n  }\n}\n","import { isFiniteUnSignInteger } from '../utils';\nimport Repos, { Chit, Payment } from '../Entites';\n\nexport default function makeCreateChit(repos: Repos) {\n  return async function createChit({ clientUuid, groupUuid, value }: { clientUuid: string; groupUuid: string; value: number }) {\n    // getting client object\n    const client = await repos.Client.findOne({ uuid: clientUuid });\n    if (!client) throw new Error('Client does not exists');\n\n    // getting group object\n    const group = await repos.Group.findOne({ uuid: groupUuid });\n    if (!group) throw new Error('Group does not exists');\n    if (group.isActive) throw new Error('Cannot add chit to an active group');\n\n    // Validating value\n    if (!isFiniteUnSignInteger(value)) throw new Error('Value of an chit is not valid');\n\n    //Creating chit object\n    let chit = new Chit();\n\n    // Asigning props\n    chit.client = client;\n    chit.group = group;\n    chit.value = value;\n    chit.wonAtMonth = null;\n    chit.payments = [];\n\n    // Creating Payments\n    for (let imonth = 1; imonth <= 20; imonth++) {\n      // Creating payment object\n      const payment = new Payment();\n\n      // Asigning props\n      payment.chit = chit;\n      payment.imonth = imonth as any;\n      payment.ispaid = false;\n\n      // Pushing payment\n      chit.payments.push(payment);\n    }\n\n    // Creating chit\n    chit = await repos.Chit.save(chit);\n\n    return Object.freeze(chit);\n  };\n}\n","import { isFiniteUnSignInteger } from '../utils';\nimport type { RangeOf2 } from '../vendorTypes';\nimport Repos, { Group } from '../Entites';\n\nexport default function makeCreateGroup(repos: Repos) {\n  return async function createGroup({ year, month, batch, totalValue }: { year: number; month: RangeOf2<1, 12>; batch: string; totalValue: number }) {\n    // Validating\n    if (!isFiniteUnSignInteger(year)) throw new Error('Year is not valid');\n    if (!isFiniteUnSignInteger(month)) throw new Error('Month is not valid');\n    if (batch.length > 3) throw new Error('Batch cannot be longer than 3');\n    if (!isFiniteUnSignInteger(totalValue)) throw new Error('Specified total value is not valid');\n\n    // Checking existance of the group\n    let count = await repos.Group.count({ year, month, batch });\n    if (count > 0) throw new Error('Group already exists');\n\n    // Creating Group Object\n    let group = new Group();\n\n    // Assigning props\n    group.year = year;\n    group.month = month;\n    group.batch = batch;\n    group.totalValue = totalValue;\n    group.isActive = false;\n    group.chits = [];\n\n    // Auto generated\n    group.name = year + '-' + month + '-' + batch;\n\n    // Saving group\n    group = await repos.Group.save(group);\n\n    return Object.freeze(group);\n  };\n}\n","import { Client } from '../Entites';\nimport type Repos from '../Entites';\n\nexport default function makeCreateClient(repos: Repos) {\n  return async function createClient({ name, phone, address }: { name: string; phone: string; address: string }) {\n    // Validating\n    if (name.length < 3) throw new Error('Name must be longer than 2 characters');\n    if (phone.length < 10) throw new Error('Phone number must be longer than 10 characters');\n    if (address.length < 5) throw new Error('Address must be longer than 5 characters');\n\n    // Checking existance of the client\n    let count = await repos.Client.count({ phone });\n    if (count > 0) throw new Error('Client with same phone number already exists');\n\n    // Creating Client object\n    let client = new Client();\n\n    // Assigning properties\n    client.name = name;\n    client.phone = phone;\n    client.address = address;\n    client.chits = [];\n\n    // Saving client\n    client = await repos.Client.save(client);\n\n    return Object.freeze(client);\n  };\n}\n","import { isFiniteUnSignInteger } from '../utils';\nimport type Repos from '../Entites';\n\nexport default function makeFindChits(repos: Repos) {\n  return async function findChits({ clientUuid, groupUuid, value }: { clientUuid?: string; groupUuid?: string; value?: number }) {\n    // getting client object\n    const client = clientUuid ? await repos.Client.findOne({ uuid: clientUuid }) : undefined;\n\n    // getting group object\n    const group = groupUuid ? await repos.Group.findOne({ uuid: groupUuid }) : undefined;\n\n    // Validating value\n    if (value && !isFiniteUnSignInteger(value)) throw new Error('Value of an chit is not valid');\n\n    const chits = repos.Chit.find({ client, group, value });\n\n    return Object.freeze(chits);\n  };\n}\n","import { isFiniteUnSignInteger } from '../utils';\nimport type { RangeOf2 } from '../vendorTypes';\nimport type { Group } from '../Entites';\nimport type Repos from '../Entites';\n\nexport default function makeFindGroups(repos: Repos) {\n  return async function findGroups(params: { partial: Partial<Group> }) {\n    if (!(params && params.partial)) return Object.freeze(await repos.Group.find());\n\n    // Validating\n    if (params.partial.year && !isFiniteUnSignInteger(params.partial.year)) throw new Error('Year is not valid');\n    if (params.partial.month && !isFiniteUnSignInteger(params.partial.month)) throw new Error('Month is not valid');\n    if (params.partial.batch && params.partial.batch.length > 3) throw new Error('Batch cannot be longer than 3');\n    if (params.partial.totalValue && !isFiniteUnSignInteger(params.partial.totalValue)) throw new Error('Specified total value is not valid');\n\n    // Searching for groups\n    let groups = await repos.Group.find({ where: params.partial });\n\n    return Object.freeze(groups);\n  };\n}\n","import type { Client } from '../Entites';\nimport type Repos from '../Entites';\n\nexport default function makeFindClients(repos: Repos) {\n  return async function findClients(params?: { partial: Partial<Client> }) {\n    if (!(params && params.partial)) return Object.freeze(await repos.Client.find());\n\n    // Validating\n    if (params.partial.name && params.partial.name.length < 3) throw new Error('Name must be longer than 2 characters');\n    if (params.partial.phone && params.partial.phone.length < 10) throw new Error('Phone number must be longer than 10 characters');\n    if (params.partial.address && params.partial.address.length < 5) throw new Error('Address must be longer than 5 characters');\n\n    // Searching for the clientrs\n    const clients = await repos.Client.find({ where: params.partial });\n\n    return Object.freeze(clients);\n  };\n}\n","import type Repos from '../Entites';\n\nexport default function makeCheckGroup(repos: Repos) {\n  return async function checkGroup({ name }: { name: string }) {\n    // Checking existance\n    let count = await repos.Group.findOne({ name });\n    return !!count;\n  };\n}\n","import 'reflect-metadata';\nimport { createConnection } from 'typeorm';\nimport type { EntityManager, ConnectionOptions, Connection } from 'typeorm';\nimport type { Actions } from './Actions';\nimport makeActions from './Actions';\nimport * as Entites from './Entites';\n\nexport type { Actions };\nexport default class Core {\n  connection?: Connection;\n  isConnected: boolean = false;\n  actions?: Actions;\n  query?: EntityManager['query'];\n\n  async connect(options: ConnectionOptions) {\n    if (this.isConnected) throw new Error('This instance is already connected');\n    this.connection = await createConnection({ ...options, entities: Object.values(Entites), synchronize: true });\n    this.isConnected = true;\n    this.loadActions();\n    this.connection.manager.query;\n  }\n  async close() {\n    if (!this.isConnected || !this.connection) return console.error(new Error('Connection is already closed'));\n    await this.connection.close();\n    this.isConnected = false;\n  }\n  loadActions() {\n    if (!this.connection) throw new Error('Cannot load actions as the instance is not connected');\n    const repos: any = {};\n    for (const key in Entites) {\n      if (Object.prototype.hasOwnProperty.call(Entites, key)) {\n        const Entity = (<any>Entites)[key];\n        repos[key] = this.connection.getRepository(Entity);\n      }\n    }\n    this.actions = makeActions(repos);\n  }\n}\n","import type Repos from '../Entites';\nimport makeCheckPhone from './checkPhone';\nimport makeCreateChit from './createChit';\nimport makeCreateGroup from './createGroup';\nimport makeCreateClient from './createClient';\nimport makeFindChits from './findChits';\nimport makeFindGroups from './findGroups';\nimport makeFindClients from './findClients';\nimport makeCheckGroup from './checkGroup';\n\nexport default function makeActions(repos: Repos) {\n  return {\n    /**\n     * checks for existance of a phone number\n     * @param {Object} params parameters to check phone\n     * @param {string} params.phone Phone number\n     * @returns {string} weather phone number exists\n     */\n    checkPhone: makeCheckPhone(repos),\n    /**\n     * checks for existance of a group\n     * @param {Object} params parameters to check group\n     * @param {string} params.name name of the group\n     * @returns {boolean} weather group exists\n     */\n    checkGroup: makeCheckGroup(repos),\n    /**\n     * Creates a new Chit\n     * @param {Object} params parameters to create Chit\n     * @param {string} params.client uuid of client to assign this chit to\n     * @param {string} params.group uuid of Group this chit belongs to and Group must not be active\n     * @param {number} params.value Value of this chit in Rupees; It must be an integer\n     * @returns created chit\n     */\n    createChit: makeCreateChit(repos),\n    /**\n     * Creates a new Group\n     * @param {Object} params parameters to create Group\n     * @param {number} params.year Year in number\n     * @param {number} params.month Month of the year\n     * @param {string} params.batch Batch of the month\n     * @param {number} params.totalValue Total value of the batch\n     * @returns created group\n     */\n    createGroup: makeCreateGroup(repos),\n    /**\n     * Creates a new Client\n     * @param {Object} params parameters to create group\n     * @param {string} params.name Name of the client\n     * @param {string} params.phone Phone number of the client\n     * @param {string} params.address Address of the client\n     * @returns created client\n     */\n    createClient: makeCreateClient(repos),\n    /**\n     * Searches and Lists all the Clients\n     * @param {Object} params params object\n     * @param params.partial partial object of client\n     */\n    findClients: makeFindClients(repos),\n    /**\n     * Finds all the groups whith params\n     * @param {Object} params params object\n     * @param params.partial partial object of group\n     */\n    findGroups: makeFindGroups(repos),\n    /**\n     * Finds all chits\n     * @param {Object} params params object\n     * @param params.partial partial object of chit\n     */\n    findChits: makeFindChits(repos),\n  };\n}\nexport type Actions = ReturnType<typeof makeActions>;\n","import Core from '../../core/src';\nexport type { Actions } from '../../core/src';\nimport initSqlJs, { SqlJsStatic } from 'sql.js';\nimport sqlWasm from 'sql.js/dist/sql-wasm.wasm';\nimport * as localforage from 'localforage';\n\nlocalforage.config({\n  name: 'chitDataStore',\n  storeName: 'chitDataStore',\n});\n\nexport async function initCore(dbName: string = 'chitDatabase') {\n  // Loading SqlJs\n  if (!window.SQL) window.SQL = await initSqlJs({ locateFile: () => sqlWasm });\n  // Mounting localforage\n  window.localforage = localforage;\n\n  const database = (await localforage.getItem<Uint8Array>(dbName)) ?? undefined;\n\n  const core = new Core();\n  await core.connect({\n    type: 'sqljs',\n    database,\n    autoSave: true,\n    logging: process.env.NODE_ENV !== 'production',\n    autoSaveCallback(ary: Uint8Array) {\n      localforage.setItem(dbName, ary);\n    },\n  });\n  return core;\n}\nexport async function getDatabaseBackup(database: string = 'chitDatabase'): Promise<File> {\n  const ary = await localforage.getItem<Uint8Array>(database);\n  if (!ary) throw new Error('Database file does not exists');\n  return new File([ary], 'backup.sqlite3', { type: 'application/vnd.sqlite3', lastModified: Date.now() });\n}\nexport async function restoreDatabase(databaseBackup: File, database: string = 'chitDatabase') {\n  await localforage.setItem(database, new Int8Array(await readFile(databaseBackup)));\n  window.location.reload();\n}\nwindow.initCore = initCore;\nexport type CoreClass = Core;\ndeclare global {\n  interface Window {\n    initCore: typeof initCore;\n    SQL: SqlJsStatic;\n    useLocalCore: true | undefined;\n    localforage: typeof localforage;\n  }\n}\nfunction readFile(file: File): Promise<ArrayBuffer> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', e => resolve((e as any).target.result));\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(file);\n  });\n}\n"],"names":["makeCheckPhone","repos","async","phone","Client","findOne","name","isFiniteUnSignInteger","num","Number","isSafeInteger","isFinite","Model","constructor","uuid","this","v4","PrimaryGeneratedColumn","Column","type","unique","CreateDateColumn","Date","UpdateDateColumn","Entity","Group","isActive","activate","Error","chitsTotalValue","chits","forEach","chit","value","totalValue","nullable","OneToMany","Chit","group","cascade","client","wonAtMonth","JoinColumn","ManyToOne","Payment","base","intrest","imonth","payments","makeCreateChit","clientUuid","groupUuid","payment","ispaid","push","save","Object","freeze","makeCreateGroup","year","month","batch","length","count","makeCreateClient","address","makeFindChits","undefined","find","makeFindGroups","params","partial","groups","where","makeFindClients","clients","makeCheckGroup","Core","isConnected","options","connection","createConnection","entities","values","synchronize","loadActions","manager","query","console","error","close","key","prototype","hasOwnProperty","call","getRepository","actions","checkPhone","checkGroup","createChit","createGroup","createClient","findClients","findGroups","findChits","makeActions","initCore","dbName","window","SQL","locateFile","localforage","database","getItem","core","connect","autoSave","logging","autoSaveCallback","ary","setItem","getDatabaseBackup","File","lastModified","now","restoreDatabase","databaseBackup","file","Int8Array","Promise","resolve","reject","reader","FileReader","addEventListener","e","target","result","readAsArrayBuffer","location","reload","config","storeName"],"sourceRoot":""}